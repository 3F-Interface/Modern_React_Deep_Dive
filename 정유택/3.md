# 3. 리액트 훅 깊게 살펴보기

## 3.1. 리액트의 모든 훅 파헤치기

### 3.1.1. useState

함수형 컴포넌트 내부에서 상태를 정의하고, 관리할 수 있게 해주는 훅

```jsx
const [state, setState] = useState(initialState)
```

- `useState`의 초깃값에 함수를 넣는 것 - 게으른 초기화 (lazy initialization)
    - 게으른 초기화 함수는 state가 처음 만들어질 때만 실행
    - 초깃값이 복잡하거나 무거운 연산을 포함할 때 사용

### 3.1.2. useEffect

애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 매커니즘

```jsx
function Component() {
	useEffect(() => {
		// code
	}, [props, state])
```

첫 번째 인수 - 실행할 부수 효과가 포함된 함수

두 번째 인수 - 의존성 배열

렌더링 시점을 기준으로 의존성에 있는 값이 변경되면 부수 효과를 실행하는 원리

`[Object.is](http://Object.is)` 기반의 얕은 비교를 수행

**클린업 함수**

- 새로운 값을 기반으로 렌더링 뒤에 실행되지만, 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행
- 즉, 렌더링 시 선언된 값을 보여줌

**주의점**

- `eslint-disable-line react-hooks/exhaustive-deps` 주석 사용 지양
    - 의존성에 빈 배열이 들어가는 경우 eslint 경고가 뜨는데 이를 막아주는 주석
    - 일반적으로 빈 배열을 넣는 상황은 만들지 않는것이 좋음
- `useEffect`의 첫 번째 인수에 함수명을 부여하기
    - 적절한 기명을 통해 쓰임을 알게하는것이 좋음
- 거대한 `useEffect` 만들기 지양
    - 작은 의존성 배열을 사용하는 여러개의 `useEffect`로 분리
    - 부득이하게 사용하게 된다면 `useCallback`, `useMemo` 등으로 사전에 정제한 내용만 담는 것이 좋음
- 불필요한 외부함수 만들기 지양
    - 콜백 함수로 비동기 함수를 바로 넣지 않는 이유 - `useEffect`의 race condition 방지
    - 내부에서 비동기 함수를 선언해 실행하거나, 즉시실행함수를 만드는 것은 가능
    - 사용 시, 클린 업 함수에서 비동기 함수에 대한 추가적인 처리를 해주는 것이 좋음 (반복생성, 실행 방지)
    
    ### 3.1.3. useMemo
    
    비용이 큰 연산에 대한 결과를 저장해 두고, 저장된 값을 반환하는 훅
    
    ```jsx
    const memo = useMemo(() => expensiveComputation(a, b), [a, b])
    ```
    
    의존성이 변경되지 않으면 함수를 재실행 하지 않음
    
    단순한 값 뿐만 아니라, 컴포넌트도 가능 (굳이..)
    
    ### 3.1.4. useCallback
    
    `useMemo`는 값을 기억, `useCallback`은 콜백 자체를 기억
    
    의존성이 변경되었을 때만 함수가 재생성
    
    ### 3.1.5. useRef
    
    `useState`와 마찬가지로 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장
    
    `current`로 값에 접근 또는 변경할 수 있음
    
    값이 변하더라도 렌더링이 발생하지 않음
    
    일반적으로 DOM에 접근할 때 사용 (input, button 등 ..)
    
    `useMemo`를 통해 구현이 가능함
    
    ### 3.1.6. useContext
    
    props drilling을 극복하기 위해 등장
    
    `<Provider>`에서 값을 가져오며, 여러개의 Provider가 있다면, 가장 가까운 Provider 값을 가져옴

## 리액트 훅 깊게 살펴보기

### useState

상태를 정의하고 관리하는 훅

```react
// 기본적인 활n
const [state, setState] = useState(initValue)
```

state는 항상 갱신된 값을 가져와야한다. `useState`내에서 변수를 할당한다면 항상 갱신된 변수를 전달하기 위해서는 state가 함수 처럼 동작해야 한다. 하지만 이것을 원하지 않기에 클로저를 활용해서 구현한다.

```js
const MyReact = function() {
  const global = {} // state와 같은 값들이 저장되는 객체
  let index = 0   
  
  function useState(initVal) {
    // 생략
    const currentState = global.states[index] || initVal
    global.states[index] = currentState
    
    const setState(value) (() => {
      // 여기에 currentIdx는 리액트가 다시 실행 되기 전까지 고정된다.
      let currentIdx = index
      return (value) => {
        global.states[currentIdx] = value
        // 리렌더링
      }
    })()
    index += 1 // 다른 useState를 위해 
    
    return [currentState, setState]
  }
}
```

이처럼 클로저로 관리하면 항상 변화 무쌍한 상태를 상수처럼 관리할 수 있습니다.

#### 게으른 초기화

`useState` 인자로 값이 아닌 함수를 넘겨주는 경우가 있는데 이를 게으론 초기화라 칭합니다, 

이를 사용하는 경우는 초기값이 복잡하거나 무거운 연산을 포함하고 있을때 사용하라고 돼 있습니다.

이의 이유는 게으른 초기화에 사용되는 함수는 초기화 이후에는 무시 되기 때문이다 하지만 함수가 아니라 값이라면 매번 새로이 값에 접근해야하기 때문에 리소스 낭비로 이어질 수 있기 때문이다.

### useEffect

```react
useEffect(()=>{
  // 초기렌더링 혹은 의존성 배열의 값이 변할 때 실행되는 함수영역
  return () => {
    // 클린업 함수
    // 언마운트 될때 실행되는 함수 영역
  }
}, [/*의존성 배열*/])
```

#### 클린업 함수의 목적

- 이벤트를 지울떼

  해당 컴포넌트에서 필요로 인해 window에 이벤트를 걸고 나서 지우지 않으면 다른 컴포넌트에서 의도치 않은 에러가 생길 수 있으므로 클린업 함수를 통해 삭제

- 비동기 작업 멈출때

  해당 컴포넌트에서 필요한 비동기 작업을 하다가 컴포넌트가 언마운트 되면 해당 비동기 작업을 필요치 않음에도 진행된다면 리소스 소모 그리고 에러로 이어질 수 있으므로 해당 비동기 작업을 멈출때 사용

**unmount는 아닌가???**

#### useEffect를 사용시 주의점

- 빈 의존성 배열 사용을 지양하자

  빈 의존성 배열을 사용해야만 한다면 부수효과를 만드는 장소가 잘못되었을 확률이 높다.

- useEffect의 첫번째 인자인 함수는 기명함수를 이용하자

  컴포넌트가 복잡해진다면 이 useEffect는 무엇을 하는지 이해하기 어려워 질 수 있다. 코드의 가독성을 위해 기명함수를 이용하자.

- 거대한 useEffect를 만들지말자

- 불필요한 외부 함수를 만들지 말자

  
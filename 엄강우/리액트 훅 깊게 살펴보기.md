## 리액트 훅 깊게 살펴보기

### useState

상태를 정의하고 관리하는 훅

```react
// 기본적인 활용
const [state, setState] = useState(initValue)
```

state는 항상 갱신된 값을 가져와야한다. `useState`내에서 변수를 할당한다면 항상 갱신된 변수를 전달하기 위해서는 state가 함수 처럼 동작해야 한다. 하지만 이것을 원하지 않기에 클로저를 활용해서 구현한다.

```js
const MyReact = function() {
  const global = {} // state와 같은 값들이 저장되는 객체
  let index = 0   
  
  function useState(initVal) {
    // 생략
    const currentState = global.states[index] || initVal
    global.states[index] = currentState
    
    const setState(value) (() => {
      // 여기에 currentIdx는 리액트가 다시 실행 되기 전까지 고정된다.
      let currentIdx = index
      return (value) => {
        global.states[currentIdx] = value
        // 리렌더링
      }
    })()
    index += 1 // 다른 useState를 위해 
    
    return [currentState, setState]
  }
}
```

이처럼 클로저로 관리하면 항상 변화 무쌍한 상태를 상수처럼 관리할 수 있습니다.

#### 게으른 초기화

`useState` 인자로 값이 아닌 함수를 넘겨주는 경우가 있는데 이를 게으론 초기화라 칭합니다, 

이를 사용하는 경우는 초기값이 복잡하거나 무거운 연산을 포함하고 있을때 사용하라고 돼 있습니다.

이의 이유는 게으른 초기화에 사용되는 함수는 초기화 이후에는 무시 되기 때문이다 하지만 함수가 아니라 값이라면 매번 새로이 값에 접근해야하기 때문에 리소스 낭비로 이어질 수 있기 때문이다.

### useEffect

```react
useEffect(()=>{
  // 초기렌더링 혹은 의존성 배열의 값이 변할 때 실행되는 함수영역
  return () => {
    // 클린업 함수
    // 언마운트 될때 실행되는 함수 영역
  }
}, [/*의존성 배열*/])
```

#### 클린업 함수의 목적

- 이벤트를 지울떼

  해당 컴포넌트에서 필요로 인해 window에 이벤트를 걸고 나서 지우지 않으면 다른 컴포넌트에서 의도치 않은 에러가 생길 수 있으므로 클린업 함수를 통해 삭제

- 비동기 작업 멈출때

  해당 컴포넌트에서 필요한 비동기 작업을 하다가 컴포넌트가 언마운트 되면 해당 비동기 작업을 필요치 않음에도 진행된다면 리소스 소모 그리고 에러로 이어질 수 있으므로 해당 비동기 작업을 멈출때 사용

**unmount는 아닌가???**

#### useEffect를 사용시 주의점

- 빈 의존성 배열 사용을 지양하자

  빈 의존성 배열을 사용해야만 한다면 부수효과를 만드는 장소가 잘못되었을 확률이 높다.

- useEffect의 첫번째 인자인 함수는 기명함수를 이용하자

  컴포넌트가 복잡해진다면 이 useEffect는 무엇을 하는지 이해하기 어려워 질 수 있다. 코드의 가독성을 위해 기명함수를 이용하자.

- 거대한 useEffect를 만들지말자

- 불필요한 외부 함수를 만들지 말자

### useMemo

큰 연산에 대한 결과를 저장해 두고 이 저장된 값을 반환하는 훅이다.

### useCallback

`useMemo`가 값을 기억한다면 콜백 그 자체를 기억하는 훅이다.

특정함수가 변하지 않았지만 리렌더링 과정에서는 당연스럽게 새로이 정의 되므로써 그 함수를 받는 컴포넌트도 자연스레 리렌더링이 될 수 있다. `useCallback`을 통해 이 함수가 변하지 않았다면 재정의 되지 않도록 할 수 있다.

### useRef

`useRef`와 `useState`는 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다는 공통점이 있다. 하지만 명확히 다른 점도 존재하는데

- `useRef`는 반환값인 객체 내부에 있는 `current`로 값에 접근 또는 변경가능하다.
- `useRef`는 그 값이 변하더라도 렌더링을 발생시키지 않는다.

### useContext

`props`드릴링을 막기 위해 등장한 개념이다.

#### useContext를 사용시 주의할 점.

컴포넌트 재활용이 어려워진다. `Provider`라는 의존성을 가지고 있는 셈이 되기 때문이다.

그리고 일부 개발자들은 `context`를 상태관리를 위한 리액트의 API로 오해하고 있지만 콘텍스트는 상태를 주입해주는 API이다. 상태관리를 위한 라이브러리는 다음 조건을 만족해야한다.

- 어떠한 상태를 기반으로 다른 상태를 만들수 있어야한다.
- 필요에 따라 이러한 상태 변화를 최적화 할 수 있어야 한다.

그러나 콘텍스트 API는 둘 중 어느 것도 하지 못한다.

### useReducer

`useState`의 심화 버전이며 좀 더 복잡한 상태 값을 미리 정의 해 놓은 시나리오에 따라 관리 할 수 있다.

- 반환값은 `[state, dispatcher]`이며 

  - state : 현재 `useReducer`가 관리하는 값을 의미
  - dispatcher : state를 업데이트하는 함수. `useState`는 단순히 값을 넘기지만 여기서는 `action`을 넘겨준다는 것이 다르다.

- 3개의 인자를 필요로 한다.

  - reducer : 기본 action을 정의하는 함수이다.
  - initialState : 초기값
  - init : 초기값을 지연시킬때 활용하는 함수이다. initialState의 인수로 init 함수가 실행된다.


### useImpreativeHandle

자주보기 힘든 훅이지만 일부 상황에서는 매우 유용할 수 있다.

#### forwarRef

는 하위 컴포넌트에서 할당된 `ref`를 상위 컴포넌트에 전달하기 위해 사용된다. `ref`를 `props`로 사양할 수 없지만 우회하여 사용하면 `forwardRef`를 사용하지 않고도 자식 컴포넌트의 `ref`를 사용할 수 있다. 하지만 명시적으로 `ref`를 전달함을 알리기 위해 `forwarRef`를 사용한다.

#### 그럼 useImpreativeHandle은?

부모 컴포넌트로 부터 받은 `ref` 마음대로 핸들링할 수 있는 훅이다. `ref`의 동작을 추가로 정의할 수 있다.

```react
useImpreativeHandle(
    ref, 
    ()=> ({alert: () => alert('hi')}), 
    [props.value]
)
```

이런식으로 `ref`를 전달받은 자식 컴포넌트에서 정의하면 부모 컴포넌트에서 `ref.current.alert`라는 메서드를 사용할 수 있게 된다.

### useLayoutEffect

**이 함수 시그니처는 useEffect와 동일하나 모든 DOM의 변경 후에 동기적으로 발생한다**

그럼 어떤 타이밍에 실행되는 것일까?

1. 리액트가 DOM을 업데이트
2. `useLayoutEffect` 실행
3. 브라우저에 변경사항 반영
4. `useEffect` 실행

`useLayoutEffect`는 동기적으로 실행되므로 `useLayoutEffect`가 끝이나야 화면을 그린다는 것을 의미한다. 즉 DOM은 업데이트 되었지만 화면이 그려지기 전에 하고 싶은 것들을 할 수 있는 훅이라고 볼 수 있다. 예를 들면 스크롤의 이동과 같은.

### useDebugValue

디버깅에 사용되는 훅이다.

### 훅의 규칙

1. 최상위 에서만 훅을 호출해야하며 조건문이나 반복문 중첩된 함수 내에서 훅을 실행할 수 없다.
2. 훅을 호출할 수 있는 것은 함수형 컴포넌트와 커스텀 훅 뿐이다.

훅의 규칙이 존재하는 이유는 리액트 내부에서 훅을 `index`로 관리하고 있음을 이전에서 배웠다면 유추할 수 있겠지만 모든 훅이 순차적으로 실행됨을 보장할 수 있어야 할 필요가 있기 때문이다.

### 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야할까?

- 일단 사용자 정의 훅은 재사용하기 굉장히 편리하다.
- 고차 컴포넌트는 함수 컴포넌트를 모두 감싸고 있다는 점에서 사용자 정의 훅과는 다른 용법을 보여줄 수 있다.

#### 선택의 기준은 무엇이 될까?

- 사용자 정의 훅이 필요한 경우

  훅을 통해 공통의 로직을 격리 할 수 있다면 사용자 정의 훅을 사용하면 좋다.

- 고차 컴포넌트 같은 경우

  로그인이 되지 않은 사용자에게 컴포넌트를 감추고 싶을때

  에러가 발생했을때 처리할 수 있는 컴포넌트를 노출하고 싶을때

  즉, 함수 컴포넌트의 반환값, 즉 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하자. 물론 너무 많은 고차 컴포넌트를 사용한다면 복잡성이 기하 급수적으로 상승하므로 신중하게 사용해야한다.